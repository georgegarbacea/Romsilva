<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Romsilva - harta indicatori</title>

<!-- Plotly local în root-ul repo-ului -->
<script src="plotly-2.35.2.min.js"></script>

<style>
  :root{--bg:#0b1020;--card:#0f172a;--ink:#e5e7eb;--muted:#9ca3af;--ring:#1f2937}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink)}
  header{padding:18px 24px;background:#0a0f1f;color:#fff;border-bottom:1px solid #111827}
  h1{margin:0;font-size:20px}
  .container{max-width:1500px;margin:0 auto;padding:18px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:14px}
  select,button{padding:10px 12px;border:1px solid var(--ring);border-radius:12px;background:#0b1223;color:#e5e7eb;cursor:pointer}
  .layout{display:grid;grid-template-columns:1fr 1fr;gap:18px}
  .card{background:var(--card);border:1px solid #111827;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:12px}
  .panel{height:760px}
  .right{display:grid;grid-template-rows:1fr 1fr;gap:18px}
  .label{font-size:13px;color:var(--muted)}
  .debug{font-size:13px;color:#cbd5e1}
  .export-row{margin-top:8px; display:flex; gap:8px}
</style>
</head>
<body>
<header>
  <h1>Romsilva – harta indicatori</h1>
</header>

<div class="container">
  <div class="controls">
    <span class="label">Indicator hartă:</span>
    <select id="metric">
      <option value="Suprafata_administrata">Suprafață administrată</option>
      <option value="Profit_ha">Profit / ha</option>
      <option value="Volum_recoltat">Volum recoltat</option>
      <option value="Scor_DS">Scor DS</option>
    </select>
    <button id="resetSel">Reset selecție județ</button>
  </div>

  <div class="layout">
    <div class="card">
      <div id="map" class="panel"></div>
      <div class="export-row"><button id="expMap">Export PNG — Hartă</button></div>
    </div>
    <div class="right">
      <div class="card">
        <div id="rankbar" style="height:100%"></div>
        <div class="export-row"><button id="expRank">Export PNG — Top județe</button></div>
      </div>
      <div class="card">
        <div id="profile" style="height:100%"></div>
        <div class="export-row"><button id="expProfile">Export PNG — Profil județ</button></div>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:18px">
    <div id="debugBox" class="debug">Încarc din repo…</div>
  </div>
</div>

<script>
// ---------- Config: fișiere din root ----------
const CSV_URL     = './Romsilva_dashboard_minimal.csv';
const GEOJSON_URL = './ro_judete_poligon.geojson';

// ---------- Utils ----------
const COLORSCALE_GWR = [[0,'#b91c1c'],[0.25,'#ef4444'],[0.5,'#ffffff'],[0.75,'#34d399'],[1,'#16a34a']];

const normName = s =>
  String(s||"").normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[–—]/g,'-').replace(/\s+/g,' ').trim();

const recaseCounty = n =>
  n.split(/(\-)/).map(p=>p==='-'?'-':(p.charAt(0).toUpperCase()+p.slice(1).toLowerCase())).join('');

function extractCounty(ds){
  let s=String(ds||"").trim(); if(!s) return '';
  let n=s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  n=n.replace(/^(Directia\s+Silvica|DS|D\.S\.)\s+/i,'').split(/[-,/()]/)[0].trim();
  if(!n) n=s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  n=recaseCounty(n.replace(/\s+/g,' ').trim());
  const fixes={'Bistrita':'Bistrita-Nasaud','Caras':'Caras-Severin','Satu mare':'Satu Mare'};
  return fixes[n] || n;
}

function parseNumSmart(v){
  if(v===null||v===undefined) return 0;
  let s=String(v).trim(); if(!s) return 0; s=s.replace(/\s+/g,'');
  const hasC=s.includes(','), hasD=s.includes('.');
  if(hasC&&hasD){ s=(s.lastIndexOf(',')>s.lastIndexOf('.'))?s.replace(/\./g,'').replace(/,/g,'.'):s.replace(/,/g,''); }
  else if(hasC){ s=s.replace(/\./g,'').replace(/,/g,'.'); }
  else { s=s.replace(/,/g,''); }
  const n=Number(s); return isNaN(n)?0:n;
}

function detectDelimiter(sample){
  const c=(sample.match(/,/g)||[]).length,s=(sample.match(/;/g)||[]).length,t=(sample.match(/\t/g)||[]).length;
  return (s>=c&&s>=t)?';':(t>=c?'\t':',');
}
function parseCSVSmart(text){
  const first5=text.split(/\r?\n/).slice(0,5).join('\n'); const delim=detectDelimiter(first5);
  const rows=[]; let cur=[],cell='',inQ=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i],nx=text[i+1];
    if(inQ){ if(ch=='"'&&nx=='"'){cell+='"';i++;continue;} if(ch=='"'){inQ=false;continue;} cell+=ch; }
    else{ if(ch=='"'){inQ=true;continue;} if(ch==delim){cur.push(cell);cell='';continue;} if(ch=='\n'){cur.push(cell);rows.push(cur);cur=[];cell='';continue;} if(ch=='\r'){continue;} cell+=ch; }
  }
  if(cell.length>0||cur.length>0){cur.push(cell);rows.push(cur);}
  const rawHeader=rows[0].map(h=>h.trim());
  const normHeader=rawHeader.map(h=>{
    let x=h.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    x=x.replace(/_/g,' ').replace(/\s+/g,' ').trim().toLowerCase();
    x=x.replace(/\s*\/\s*/g,'/'); return x;
  });
  const canon={'directia silvica':'Directia Silvica','ds':'Directia Silvica','directia-silvica':'Directia Silvica',
    'suprafata administrata':'Suprafata administrata','suprafata':'Suprafata administrata',
    'profit/ha':'Profit/ha','profit ha':'Profit/ha',
    'volum recoltat':'Volum recoltat','volum':'Volum recoltat',
    'scor ds':'Scor_DS','scor_ds':'Scor_DS','scor':'Scor_DS'};
  const idx={}; for(let i=0;i<normHeader.length;i++){const h=normHeader[i]; if(canon[h] && idx[canon[h]]===undefined) idx[canon[h]]=i;}
  const req=['Directia Silvica','Suprafata administrata','Profit/ha','Volum recoltat','Scor_DS'];
  const miss=req.filter(k=>idx[k]===undefined); if(miss.length) throw new Error('Lipsesc coloane: '+miss.join(', '));
  const out=[]; for(let r=1;r<rows.length;r++){
    const arr=rows[r]; if(!arr||arr.every(x=>String(x||'').trim()==='')) continue;
    const o={}; for(const k of req){const j=idx[k]; o[k]=arr[j]!==undefined?arr[j].trim():'';} out.push(o);
  }
  return out;
}

// ---------- State ----------
let rows=[], geoData=null, selectedJudet=null;
const metricSel=document.getElementById('metric'), debugBox=document.getElementById('debugBox');

// ---------- Load ----------
(async ()=>{
  try{
    const [csvRes, geoRes] = await Promise.all([
      fetch(CSV_URL,{cache:'no-store'}), fetch(GEOJSON_URL,{cache:'no-store'})
    ]);
    const [csvText, geoText] = await Promise.all([ csvRes.text(), geoRes.text() ]);

    const raw = parseCSVSmart(csvText);
    rows = raw.map(r=>{
      const ds=r['Directia Silvica'], j=extractCounty(ds);
      return {
        Directia_Silvica: ds,
        Judet: recaseCounty(j),
        Judet_norm: normName(j),
        Suprafata_administrata: parseNumSmart(r['Suprafata administrata']),
        Profit_ha:           parseNumSmart(r['Profit/ha']),
        Volum_recoltat:      parseNumSmart(r['Volum recoltat']),
        Scor_DS:             parseNumSmart(r['Scor_DS'])
      };
    });

    geoData = JSON.parse(geoText);
    // suprascriem properties.name normalizat (cheia de potrivire)
    (geoData.features||[]).forEach(f=>{
      const p=f.properties||(f.properties={});
      p.name = normName(p.name||p.judet||p.JUDET||p.NAME_1||p.shapeName||p.nume||p.denumire||'');
    });

    drawAll(true);
    debugBox.textContent='Încărcat din repo.';
  }catch(e){
    debugBox.textContent='Eroare încărcare: '+e.message;
  }
})();

// ---------- Render ----------
function drawAll(resetBBox=false){ drawMap(resetBBox); drawRankBar(); drawProfile(); selfTest(); }

function selfTest(){
  if(!geoData||!rows.length){ return; }
  const geoNames = new Set((geoData.features||[]).map(f => normName(String(f.properties?.name||''))));
  const dataNames = new Set(rows.map(r => r.Judet_norm));
  const missingInGeo = [...dataNames].filter(n => !geoNames.has(n));
  const missingInData = [...geoNames].filter(n => !dataNames.has(n));
  debugBox.innerHTML = `Potriviri: ${rows.length - missingInGeo.length}/${rows.length}`
    + (missingInGeo.length? `<br>În CSV dar nu în GeoJSON: ${missingInGeo.slice(0,5).join(', ')}`:'')
    + (missingInData.length? `<br>În GeoJSON dar fără date: ${missingInData.slice(0,5).join(', ')}`:'');
}

function drawMap(resetBBox){
  if(!geoData||!rows.length){ Plotly.purge('map'); return; }
  const m = metricSel.value;

  // 1) normalizăm identic și ne asigurăm că properties.name e cheia
  const locs = (geoData.features||[]).map(f=>{
    const raw = (f.properties && (f.properties.name || f.properties.judet || f.properties.JUDET || f.properties.NAME_1 || f.properties.shapeName)) || '';
    const nn = normName(String(raw));
    if (f.properties) f.properties.name = nn;
    return nn;
  });

  const byName = Object.fromEntries(rows.map(r=>[r.Judet_norm,r]));

  // 2) extragem valori; calculăm zmin/zmax din date (ignorăm null/NaN)
  const z = locs.map(n => (byName[n] ? byName[n][m] : null));
  const valid = z.filter(v => typeof v==='number' && isFinite(v));
  const zmin = valid.length ? Math.min(...valid) : 0;
  const zmax = valid.length ? Math.max(...valid) : 1;

  const text = locs.map(n => {
    const r=byName[n], v=(r? r[m] : null);
    return r ? `${r.Judet} — ${ (v??0).toLocaleString('ro-RO',{maximumFractionDigits:3}) }` : 'Fără date';
  });

  // 3) contur + strat principal
  const outline = {
    type:'choropleth',
    geojson: geoData,
    locations: locs,
    z: locs.map(()=>0),
    showscale:false,
    featureidkey:'properties.name',
    hoverinfo:'skip',
    colorscale:[[0,'#0b1020'],[1,'#0b1020']],
    marker:{ line:{ width:1.2, color:'#0f172a' } },
    opacity:1
  };

  const main = {
    type:'choropleth',
    geojson: geoData,
    locations: locs,
    z, zmin, zmax,
    text,
    featureidkey:'properties.name',
    colorscale: COLORSCALE_GWR,
    marker:{ line:{ width:0.8, color:'#0b1020' } },
    hoverinfo:'text',
    colorbar:{ title:m.replace('_',' '), thickness:16, len:0.9, x:1.02, y:0.5, xpad:6, outlinewidth:0 }
  };

  // 4) încadrăm robust pe locații
  const layout = {
    margin:{l:8,r:70,t:4,b:4},
    geo:{
      visible:true, showframe:false, showcoastlines:false, bgcolor:'#0b1020',
      projection:{type:'mercator'},
      fitbounds:'locations'
    },
    hovermode:'closest',
    paper_bgcolor:'#0b1020', plot_bgcolor:'#0b1020',
    uirevision:'keep'
  };

  // Pan DA, zoom NU
  const cfg = { responsive:true, displayModeBar:false, scrollZoom:false, doubleClick:false };

  if(!drawMap._inited || resetBBox){
    Plotly.newPlot('map',[outline,main],layout,cfg).then(()=>{ drawMap._inited=true; });
  }else{
    Plotly.react('map',[outline,main],layout,cfg);
  }

  document.getElementById('map').on('plotly_click',ev=>{
    const loc = ev.points?.[0]?.location; if(!loc) return;
    const rec = rows.find(r=>r.Judet_norm===loc); selectedJudet = rec ? rec.Judet : null;
    drawRankBar(); drawProfile();
  });
}

function drawRankBar(){
  if(!rows.length){ Plotly.purge('rankbar'); return; }
  const m=metricSel.value;
  const sorted=[...rows].sort((a,b)=>(b[m]??-Infinity)-(a[m]??-Infinity));
  Plotly.react('rankbar',[{
    type:'bar', orientation:'h',
    y:sorted.map(r=>r.Judet),
    x:sorted.map(r=>r[m]),
    text:sorted.map(r=>(r[m]??0).toLocaleString('ro-RO',{maximumFractionDigits:3})),
    textposition:'auto',
    marker:{ color:sorted.map(r=>(selectedJudet&&r.Judet===selectedJudet)?'#f59e0b':'#6366f1') }
  }],{
    margin:{l:140,r:20,t:10,b:30},
    xaxis:{title:m.replace('_',' ')},
    paper_bgcolor:'#0f172a', plot_bgcolor:'#0f172a',
    uirevision:'keep'
  }, {responsive:true});

  document.getElementById('rankbar').on('plotly_click',ev=>{
    const jd=ev.points?.[0]?.y; if(!jd) return;
    selectedJudet=jd; drawProfile(); drawMap(false);
  });
}

function drawProfile(){
  if(!rows.length){ Plotly.purge('profile'); return; }
  const r=selectedJudet?rows.find(x=>x.Judet===selectedJudet):null;
  const title=r?`Profil indicatori — ${r.Judet}`:'Profil indicatori — selectează un județ';
  const x=['Suprafață administrată','Profit / ha','Volum recoltat','Scor DS'];
  const y=r?[r.Suprafata_administrata,r.Profit_ha,r.Volum_recoltat,r.Scor_DS]:[0,0,0,0];
  Plotly.react('profile',[{
    type:'bar', x, y,
    text:y.map(v=>(v??0).toLocaleString('ro-RO',{maximumFractionDigits:3})), textposition:'auto',
    marker:{color:['#22c55e','#f59e0b','#22d3ee','#a78bfa']}
  }],{
    title, yaxis:{title:'Valoare'},
    margin:{l:60,r:20,t:40,b:60},
    paper_bgcolor:'#0f172a', plot_bgcolor:'#0f172a',
    uirevision:'keep'
  }, {responsive:true});
}

// ---------- Export PNG ----------
function exportPng(id,name){
  Plotly.downloadImage(document.getElementById(id), {format:'png', width:1200, height:800, filename:name})
    .catch(e=>alert('Export PNG: '+e.message));
}
document.getElementById('expMap').addEventListener('click',()=>exportPng('map','harta_romsilva'));
document.getElementById('expRank').addEventListener('click',()=>exportPng('rankbar','top_judete'));
document.getElementById('expProfile').addEventListener('click',()=>exportPng('profile','profil_judet'));

// ---------- UI ----------
document.getElementById('resetSel').addEventListener('click',()=>{ selectedJudet=null; drawRankBar(); drawProfile(); drawMap(true); });
metricSel.addEventListener('change',()=>{ selectedJudet=null; drawAll(false); });
</script>
</body>
</html>

